{"version":3,"file":"conform-function.spec.js","sourceRoot":"","sources":["conform-function.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from \"chai\";\nimport * as esprima from 'esprima'\nimport { Identifier, IdentifierType } from \"../../source/name_extraction/Identifier\";\nimport { Function } from \"../../source/name_extraction/Rules/Function\";\ndescribe(\"recognize function\", () => {\n    describe('#extract', () => {\n        it('extracts a function from a function declaration *with no params*', () => {\n            ['function myFunc() {}'].forEach(declaration => {\n                const identifyer = new Function(createNode(declaration)).extract()\n                expect(identifyer).to.have.property('name', 'myFunc')\n                expect(identifyer).to.be.instanceOf(Identifier)\n                expect(identifyer).to.have.property('type', IdentifierType.Function)\n            })\n        })\n\n        it('extracts a function with it\\'s parameter from function decleration', () => {\n            ['function myFunc(param1) {}'].forEach(declaration => {\n                const identifyer = new Function(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(2)\n                expect(identifyer[0]).to.have.property('name', 'param1')\n                expect(identifyer[1]).to.have.property('name', 'myFunc')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[1]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Parameter)\n                expect(identifyer[1]).to.have.property('type', IdentifierType.Function)\n            })\n        })\n        it('extracts a function with multiple parameters from function decleration', () => {\n            ['function myFunc(param1,param2) {}'].forEach(declaration => {\n                const identifyer = new Function(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(3)\n                expect(identifyer[0]).to.have.property('name', 'param1')\n                expect(identifyer[1]).to.have.property('name', 'param2')\n                expect(identifyer[2]).to.have.property('name', 'myFunc')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[1]).to.be.instanceOf(Identifier)\n                expect(identifyer[2]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Parameter)\n                expect(identifyer[1]).to.have.property('type', IdentifierType.Parameter)\n                expect(identifyer[2]).to.have.property('type', IdentifierType.Function)\n            })\n        })\n\n        it('does not extracts a function from a node that do not contains a function identifyer', () => {\n            ['person.name = function () {}', 'firstName: \"moshe\"'].forEach(declaration => {\n                const identifyer = new Function(createNode(declaration)).extract()\n                expect(identifyer).to.be.false\n            })\n        })\n\n    })\n})\n\nfunction createNode(expression) {\n    return esprima.parseScript(expression).body.pop()\n}\n"]}