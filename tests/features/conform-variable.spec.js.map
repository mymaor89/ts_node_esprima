{"version":3,"file":"conform-variable.spec.js","sourceRoot":"","sources":["conform-variable.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from \"chai\";\nimport * as esprima from 'esprima'\nimport {Variable} from '../../source/name_extraction/Rules/Variable'\nimport { Identifier, IdentifierType } from \"../../source/name_extraction/Identifier\";\n\ndescribe(\"recognize variable\", () => {\n    describe('#extract', () => {\n        it('extracts a variable from a variable declaration', () => {\n            ['var x = 9', 'let x = 9', 'const x = 9'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n            \n                expect(identifyer).to.be.an('array').with.lengthOf(1)\n                expect(identifyer[0]).to.have.property('name', 'x')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Variable)\n            })\n        })\n        \n        it('extracts multiple variables from a variable list declartion', () => {\n            ['var x = 9,y= 6', 'let x= 5, y =4 ', 'const x = 9, y = 3'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(2)\n              \n                expect(identifyer[0]).to.have.property('name', 'x')\n                expect(identifyer[1]).to.have.property('name', 'y')\n              \n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[1]).to.be.instanceOf(Identifier)\n\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Variable)\n                expect(identifyer[1]).to.have.property('type', IdentifierType.Variable)\n            })\n        })\n\n        it('should extract Function decleration identifier ', () => {\n            ['var x = function(){return true}'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n\n                expect(identifyer).to.be.an('array').with.lengthOf(1)\n                expect(identifyer[0]).to.have.property('name', 'x')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Function)\n            })\n        })\n        it('should extract Arrow Function decleration identifier ', () => {\n            ['const add = (a, b) => a + b'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(1)\n                expect(identifyer[0]).to.have.property('name', 'add')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.ArrowFunction)\n            })\n        })\n        it('should extract array decleration identifier ', () => {\n            ['var x = [1,2,3]'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(1)\n                expect(identifyer[0]).to.have.property('name', 'x')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Array)\n            })\n        })\n        \n        it('should extract object literal decleration identifier ', () => {\n            ['var myObject = {  prop1: \"hello\",  prop2: \"world\"  }'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n\n                expect(identifyer).to.be.an('array').with.lengthOf(1)\n                expect(identifyer[0]).to.have.property('name', 'myObject')\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Object_Literal)\n            })\n        })\n        it('can extracted a mixed decleration', () => {\n            ['var x = 9,y= function(){return true},z=[\"hey\",\"bye\"]'].forEach(declaration => {\n                const identifyer = new Variable(createNode(declaration)).extract()\n                expect(identifyer).to.be.an('array').with.lengthOf(3)\n                expect(identifyer[0]).to.have.property('name', 'x')\n                expect(identifyer[1]).to.have.property('name', 'y')\n                expect(identifyer[2]).to.have.property('name', 'z')\n\n                expect(identifyer[0]).to.be.instanceOf(Identifier)\n                expect(identifyer[1]).to.be.instanceOf(Identifier)\n                expect(identifyer[2]).to.be.instanceOf(Identifier)\n\n                expect(identifyer[0]).to.have.property('type', IdentifierType.Variable)\n                expect(identifyer[1]).to.have.property('type', IdentifierType.Function)\n                expect(identifyer[2]).to.have.property('type', IdentifierType.Array)\n            })\n        })\n\n            it('does not extracts a variable from a node that do not contains a variable identifyer', () => {\n                ['person.name = function () {}', 'firstName: \"moshe\"'].forEach(declaration => {\n                    const identifyer = new Variable(createNode(declaration)).extract()\n                    expect(identifyer).to.be.false\n                })\n            })\n          \n        })\n    })\n    \n    function createNode(expression) {\n        return esprima.parseScript(expression).body.pop()\n    }\n"]}