{"version":3,"file":"Tree.js","sourceRoot":"","sources":["../../source/name_extraction/Tree.ts"],"names":[],"mappings":";;AAAA,mDAA+C;AAG/C,6CAA6C;AAC7C,yBAAwB;AACxB,mCAAkC;AAMlC,+CAA0C;AAC1C,+CAA0C;AAC1C,yCAAoC;AAGpC,MAAa,IAAI;IAKb,YAAY,IAAY;QAFd,UAAK,GAAU,CAAC,mBAAQ,EAAC,mBAAQ,EAAC,aAAK,CAAC,CAAC;QAG/C,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC/C,CAAC;IAGD,OAAO;QACH,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,6BAAa,EAAE,CAAC,CAAC;IAC9C,CAAC;IAGS,WAAW,CAAC,IAAU;QAC5B,OAAO,IAAI,CAAC,KAAK;aACZ,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;aAC3B,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAA;IAEpC,CAAC;IAEO,QAAQ,CAAC,GAAkB;QAC/B,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;YACrD,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAA;QACtC,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACf,CAAC;CACJ;AA5BD,oBA4BC","sourcesContent":["import { IdentifierBag } from './IdentifierBag'\nimport { Identifier } from './Identifier';\nimport { Rules } from './Rules/Rules'\n//import { Variable } from './Rules/Variable'\nimport * as fs from 'fs'\nimport * as esprima from 'esprima'\n//import { PropertyAsignment } from './Rules/PropertyAsignment';\n//import { PropertySemicolon } from './Rules/PropertySemicolon';\n//import { MethodExpression } from './Rules/MethodExpression';\n//import { Class } from './Rules/Class';\nimport { Program, Node } from 'estree';\nimport {Variable} from \"./Rules/Variable\";\nimport {Function} from \"./Rules/Function\";\nimport {Class} from \"./Rules/Class\";\n\n\nexport class Tree {\n    code: string;\n\n    protected rules: any[] = [Variable,Function,Class];\n\n    constructor(file: string) {\n        this.code = fs.readFileSync(file, 'utf-8');\n    }\n\n\n    collect(): IdentifierBag {\n        return this.traverse(new IdentifierBag());\n    }\n\n\n    protected extractNode(node: Node): Identifier | Identifier[] {\n        return this.rules\n            .map(rule => new rule(node))\n            .map(rule => rule.extract())\n\n    }\n\n    private traverse(bag: IdentifierBag): IdentifierBag {\n        esprima.parseModule(this.code, undefined, (node, meta) => {\n            bag.append(this.extractNode(node))\n        });\n        return bag;\n    }\n}\n"]}