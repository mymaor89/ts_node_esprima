{"version":3,"file":"Class.js","sourceRoot":"","sources":["../../../source/name_extraction/Rules/Class.ts"],"names":[],"mappings":";;AAAA,mCAAgC;AAChC,8CAA2D;AAI3D,MAAa,KAAM,SAAQ,aAAK;IAElB,QAAQ;QACd,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,WAAW,CAAC,CAAA;IAEhD,CAAC;IACD,MAAM;QACF,IAAI,WAAW,GAAyB,EAAE,CAAA;QAC1C,IAAI,UAAU,GAAwB,IAAI,CAAC,IAAyB,CAAC,IAAI,CAAC,IAAI,CAAA;QAC9E,IAAI,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE;YACxB,KAAK,IAAI,GAAG,IAAI,UAAU,EAAE;gBACxB,IAAI,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAA;gBAC7B,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE;oBACtB,IAAI,MAAM,IAAI,KAAK;wBACf,WAAW,CAAC,IAAI,CAAC,uBAAU,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAA;oBAC1D,IAAK,GAAwB,CAAC,IAAI,KAAK,aAAa,EAAE;wBAClD,IAAI,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAA;wBACjC,KAAK,IAAI,GAAG,IAAI,OAAO,EAAE;4BACrB,IAAI,GAAG,CAAC,IAAI,KAAK,qBAAqB;gCAClC,GAAG,CAAC,UAAU,CAAC,IAAI,KAAK,sBAAsB;gCAC9C,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB,EAAE;gCACjD,IAAI,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE;oCACxC,IAAI,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAA;oCAChD,WAAW,CAAC,IAAI,CAAC,uBAAU,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAA;iCACtD;6BACJ;yBACJ;qBACJ;yBACI;wBACD,IAAI,MAAM,IAAI,GAAG,CAAC,GAAG;4BACjB,WAAW,CAAC,IAAI,CAAC,uBAAU,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAA;qBAC5D;iBACJ;aAEJ;YAED,aAAa;YACb,WAAW,CAAC,IAAI,CAAC,uBAAU,CAAC,SAAS,CAAE,IAAI,CAAC,IAAyB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAA;YAC/E,OAAO,WAAW,CAAA;SACrB;aACI;YAED,aAAa;YACb,OAAO,uBAAU,CAAC,SAAS,CAAE,IAAI,CAAC,IAAyB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;SACvE;IACL,CAAC;CACJ;AA9CD,sBA8CC","sourcesContent":["import { Rules } from \"./Rules\";\nimport { Identifier, IdentifierType } from \"../Identifier\";\n\n//import { PropertyAsignment } from \"./PropertyAsignment\"\nimport { ClassDeclaration, ClassBody, MethodDefinition, ClassExpression } from \"estree\";\nexport class Class extends Rules {\n\n    protected conforms(): boolean {\n        return (this.node.type === this.declaration)\n\n    }\n    handle() {\n        let identifiers: Identifier[] | false = []\n        let class_body: MethodDefinition[] = (this.node as ClassDeclaration).body.body\n        if (class_body.length != 0) {\n            for (let ele of class_body) {\n                let params = ele.value.params\n                for (var param of params) {\n                    if ('name' in param)\n                        identifiers.push(Identifier.fromParameter(param.name))\n                    if ((ele as MethodDefinition).kind === 'constructor') {\n                        let members = ele.value.body.body\n                        for (var mem of members) {\n                            if (mem.type === 'ExpressionStatement' &&\n                                mem.expression.type === 'AssignmentExpression' &&\n                                mem.expression.left.type === 'MemberExpression') {\n                                if ('name' in mem.expression.left.property) {\n                                    let mem_name = mem.expression.left.property.name\n                                    identifiers.push(Identifier.fromProperty(mem_name))\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        if ('name' in ele.key)\n                            identifiers.push(Identifier.fromMethod(ele.key.name))\n                    }\n                }\n\n            }\n            \n            // @ts-ignore\n            identifiers.push(Identifier.fromClass((this.node as ClassDeclaration).id.name))\n            return identifiers\n        }\n        else {\n            \n            // @ts-ignore\n            return Identifier.fromClass((this.node as ClassDeclaration).id.name)\n        }\n    }\n}\n"]}