{"version":3,"file":"ObjectLiteral.js","sourceRoot":"","sources":["../../../source/name_extraction/Rules/ObjectLiteral.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuCG","sourcesContent":["/*import { Rules } from './Rules'\nimport { Identifier } from '../Identifier';\nimport {ExpressionStatement,AssignmentExpression,ObjectExpression} from \"estree\";\nexport class ObjectLiteral extends Rules {\n\n    protected conforms(): boolean {\n\n            if (this.node.type === 'ExpressionStatement') {\n                if (this.node.expression.type === 'AssignmentExpression') {\n                    return this.node.expression.right.type === 'ObjectExpression'\n                }\n            }\n\n        return false\n    }\n\n    handle(): Identifier | Identifier[] {\n        let identifiers: Identifier[] | false = []\n        //iterate over object literal properties\n        const props = this.node.right.properties\n        if (props.length != 0){\n            for (let prop of props) {\n\n                if (prop.value.type === 'Literal') {\n                    identifiers.push(Identifier.fromProperty(prop.key.name))\n                }\n\n                else if (prop.value.type === 'FunctionExpression') {\n                    identifiers.push(Identifier.fromFunction(prop.key.name))\n                }\n\n                else if (prop.value.type === 'ArrowFunctionExpression') {\n                    identifiers.push(Identifier.fromArrowFunction(prop.key.name))\n                }\n            }\n            identifiers.push(Identifier.fromObjectLiteral(this.node.expression.left.name))\n            return identifiers\n        }\n    }\n}*/"]}