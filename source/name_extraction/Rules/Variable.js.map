{"version":3,"file":"Variable.js","sourceRoot":"","sources":["Variable.ts"],"names":[],"mappings":";;AAAA,mCAA+B;AAC/B,8CAA0D;AAU1D,MAAa,QAAS,SAAQ,aAAK;IAI/B,QAAQ;QACL,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAA;IAClD,CAAC;IAED,MAAM;QACF,IAAI,CAAC,OAAO,GAAI,IAAI,CAAC,IAA4B,CAAC,YAAY,CAAC;QAC/D,IAAI,WAAW,GAAiB,EAAE,CAAC;QACnC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;YACjC,IAAI,MAAM,IAAI,WAAW,CAAC,EAAE,EAAE;gBAC1B,WAAW,CAAC,IAAI,CAAC,IAAI,uBAAU,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,EAC9C,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;aAC1C;QAEL,CAAC,CAAC,CAAC;QACE,OAAO,WAAW,CAAA;IAC3B,CAAC;IAES,cAAc,CAAC,WAA+B;QACpD,4BAA4B;QAC5B,qCAAqC;QACrC,IAAI,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC;YAC/B,OAAO,2BAAc,CAAC,QAAQ,CAAC;QACnC,mBAAmB;aACd,IAAI,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;YACpC,OAAO,2BAAc,CAAC,KAAK,CAAA;SAC9B;QACD,gCAAgC;aAE3B,IAAI,QAAQ,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;YACvC,OAAO,2BAAc,CAAC,QAAQ,CAAA;SACjC;QACD,gCAAgC;aAE3B,IAAI,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC,EAAE;YAC5C,OAAO,2BAAc,CAAC,aAAa,CAAA;SAEtC;aAAM,IAAI,QAAQ,CAAC,kBAAkB,EAAE;YACpC,OAAO,2BAAc,CAAC,cAAc,CAAA;SACvC;aACI;YACD,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAA;SACpC;IACL,CAAC;IAED,MAAM,CAAC,SAAS,CAAC,WAAgB;QACzB,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAA;IAClD,CAAC;IACD,MAAM,CAAC,OAAO,CAAC,WAAgB;QAC3B,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAA;IACtD,CAAC;IACD,MAAM,CAAC,UAAU,CAAC,WAAgB;QAC9B,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,IAAI,oBAAoB,CAAA;IACxD,CAAC;IACD,MAAM,CAAC,eAAe,CAAC,WAAgB;QACnC,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,yBAAyB,CAAA;IAC9D,CAAC;IACD,MAAM,CAAC,kBAAkB,CAAC,WAAgB;QACtC,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB,CAAA;IACvD,CAAC;CAEJ;AAhED,4BAgEC","sourcesContent":["import { Rules } from './Rules'\nimport { Identifier, IdentifierType } from '../Identifier'\nimport {\n    ArrayExpression,\n    ArrowFunctionExpression,\n    Declaration, FunctionExpression,\n    Literal, ObjectExpression,\n    VariableDeclaration,\n    VariableDeclarator\n} from 'estree';\n\nexport class Variable extends Rules {\n\n    protected varDecs: VariableDeclarator[];\n\n    conforms(): boolean {\n       return this.node.type === 'VariableDeclaration'\n    }\n\n    handle(): Identifier | Identifier[] {\n        this.varDecs = (this.node as VariableDeclaration).declarations;\n        let identifiers: Identifier[] = [];\n        this.varDecs.forEach((declaration) => {\n            if (\"name\" in declaration.id) {\n                identifiers.push(new Identifier(declaration.id.name,\n                     this.identifierType(declaration)))\n            }\n\n        });\n             return identifiers\n    }\n\n    protected identifierType(declaration: VariableDeclarator): IdentifierType {\n        //**TypeScript TypeGuards!**\n        //var x= 3 , let x = 4 , const x = 4;\n        if (Variable.isLiteral(declaration))\n            return IdentifierType.Variable;\n        //let arr = [1,2,3]\n        else if (Variable.isArray(declaration)) {\n            return IdentifierType.Array\n        }\n        //let y= function(){return true}\n\n        else if (Variable.isFunction(declaration)) {\n            return IdentifierType.Function\n        }\n        //let y= function(){return true}\n\n        else if (Variable.isArrowFunction(declaration)) {\n            return IdentifierType.ArrowFunction\n\n        } else if (Variable.isObjectExpression) {\n            return IdentifierType.Object_Literal\n        }\n        else {\n            throw new Error(\"not Recognized\")\n        }\n    }\n\n    static isLiteral(declaration: any):boolean{\n            return declaration.init.type === 'Literal'\n    }\n    static isArray(declaration: any):boolean{\n        return declaration.init.type === 'ArrayExpression'\n    }\n    static isFunction(declaration: any):boolean{\n        return declaration.init.type == 'FunctionExpression'\n    }\n    static isArrowFunction(declaration: any):boolean{\n        return declaration.init.type === 'ArrowFunctionExpression'\n    }\n    static isObjectExpression(declaration: any):boolean{\n        return declaration.init.type === 'ObjectExpression'\n    }\n\n}\n"]}